"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   chatNonStream: () => (/* binding */ chatNonStream),\n/* harmony export */   chatStream: () => (/* binding */ chatStream),\n/* harmony export */   fetchCosts: () => (/* binding */ fetchCosts),\n/* harmony export */   fetchPromptLog: () => (/* binding */ fetchPromptLog),\n/* harmony export */   getAuthConfig: () => (/* binding */ getAuthConfig),\n/* harmony export */   getLoginUrl: () => (/* binding */ getLoginUrl),\n/* harmony export */   getMe: () => (/* binding */ getMe),\n/* harmony export */   saveSettings: () => (/* binding */ saveSettings),\n/* harmony export */   validateCredentials: () => (/* binding */ validateCredentials)\n/* harmony export */ });\n/** Use relative paths so the browser hits the same origin; Next.js rewrites proxy to the gateway (no CORS). */ function apiUrl(path) {\n    return path.startsWith('/') ? path : \"/\".concat(path);\n}\nasync function chatStream(opts, onChunk, onDone) {\n    var _res_body;\n    const headers = {\n        'Content-Type': 'application/json'\n    };\n    if (opts.sessionToken) {\n        headers['X-Session-Token'] = opts.sessionToken;\n    } else if (opts.apiKey) {\n        headers['Authorization'] = \"Bearer \".concat(opts.apiKey);\n    }\n    if (opts.upstream) headers['X-AI-Gateway-Upstream'] = opts.upstream;\n    const res = await fetch(apiUrl('/v1/chat/completions'), {\n        method: 'POST',\n        headers,\n        body: JSON.stringify({\n            model: opts.model,\n            messages: opts.messages,\n            stream: true\n        })\n    });\n    if (!res.ok) {\n        var _err_error;\n        const err = await res.json().catch(()=>({}));\n        throw new Error(((_err_error = err.error) === null || _err_error === void 0 ? void 0 : _err_error.message) || res.statusText);\n    }\n    const reader = (_res_body = res.body) === null || _res_body === void 0 ? void 0 : _res_body.getReader();\n    if (!reader) throw new Error('No response body');\n    const decoder = new TextDecoder();\n    let buffer = '';\n    try {\n        while(true){\n            const { done, value } = await reader.read();\n            if (done) break;\n            buffer += decoder.decode(value, {\n                stream: true\n            });\n            const lines = buffer.split('\\n');\n            var _lines_pop;\n            buffer = (_lines_pop = lines.pop()) !== null && _lines_pop !== void 0 ? _lines_pop : '';\n            for (const line of lines){\n                if (line.startsWith('data: ')) {\n                    const data = line.slice(6);\n                    if (data === '[DONE]') continue;\n                    try {\n                        var _j_choices__delta, _j_choices_, _j_choices;\n                        const j = JSON.parse(data);\n                        const content = (_j_choices = j.choices) === null || _j_choices === void 0 ? void 0 : (_j_choices_ = _j_choices[0]) === null || _j_choices_ === void 0 ? void 0 : (_j_choices__delta = _j_choices_.delta) === null || _j_choices__delta === void 0 ? void 0 : _j_choices__delta.content;\n                        if (content) onChunk(content);\n                    } catch (e) {\n                    // skip malformed chunk\n                    }\n                }\n            }\n        }\n    } finally{\n        onDone === null || onDone === void 0 ? void 0 : onDone();\n    }\n}\nasync function chatNonStream(opts) {\n    var _data_choices__message, _data_choices_, _data_choices;\n    const headers = {\n        'Content-Type': 'application/json'\n    };\n    if (opts.sessionToken) headers['X-Session-Token'] = opts.sessionToken;\n    else if (opts.apiKey) headers['Authorization'] = \"Bearer \".concat(opts.apiKey);\n    if (opts.upstream) headers['X-AI-Gateway-Upstream'] = opts.upstream;\n    const res = await fetch(apiUrl('/v1/chat/completions'), {\n        method: 'POST',\n        headers,\n        body: JSON.stringify({\n            model: opts.model,\n            messages: opts.messages,\n            stream: false\n        })\n    });\n    if (!res.ok) {\n        var _err_error;\n        const err = await res.json().catch(()=>({}));\n        throw new Error(((_err_error = err.error) === null || _err_error === void 0 ? void 0 : _err_error.message) || res.statusText);\n    }\n    const data = await res.json();\n    var _data_choices__message_content;\n    return (_data_choices__message_content = (_data_choices = data.choices) === null || _data_choices === void 0 ? void 0 : (_data_choices_ = _data_choices[0]) === null || _data_choices_ === void 0 ? void 0 : (_data_choices__message = _data_choices_.message) === null || _data_choices__message === void 0 ? void 0 : _data_choices__message.content) !== null && _data_choices__message_content !== void 0 ? _data_choices__message_content : '';\n}\n/** Minimal request to verify the API key works; throws on invalid/error. */ async function validateCredentials(opts) {\n    const headers = {\n        'Content-Type': 'application/json',\n        Authorization: \"Bearer \".concat(opts.apiKey)\n    };\n    if (opts.upstream) headers['X-AI-Gateway-Upstream'] = opts.upstream;\n    const res = await fetch(apiUrl('/v1/chat/completions'), {\n        method: 'POST',\n        headers,\n        body: JSON.stringify({\n            model: opts.model,\n            messages: [\n                {\n                    role: 'user',\n                    content: 'Hi'\n                }\n            ],\n            max_tokens: 1,\n            stream: false\n        })\n    });\n    if (!res.ok) {\n        var _err_error;\n        const err = await res.json().catch(()=>({}));\n        const msg = (_err_error = err.error) === null || _err_error === void 0 ? void 0 : _err_error.message;\n        throw new Error(msg || res.statusText || 'Invalid credentials');\n    }\n}\nasync function fetchCosts() {\n    const res = await fetch(apiUrl('/api/costs'));\n    if (!res.ok) throw new Error(res.statusText);\n    return res.json();\n}\nasync function fetchPromptLog() {\n    let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 50;\n    const res = await fetch(apiUrl(\"/api/prompt-log?limit=\".concat(limit)));\n    if (!res.ok) throw new Error(res.statusText);\n    return res.json();\n}\n/** Auth â€” config from our proxy route (path chosen so it is not rewritten to the gateway). */ async function getAuthConfig() {\n    const res = await fetch('/gateway-auth-config');\n    if (!res.ok) return {\n        ssoEnabled: false,\n        loginUrl: null\n    };\n    return res.json();\n}\nasync function getMe(sessionToken) {\n    const res = await fetch(apiUrl('/auth/me'), {\n        headers: {\n            'X-Session-Token': sessionToken\n        }\n    });\n    if (!res.ok) throw new Error('Session invalid');\n    return res.json();\n}\nasync function saveSettings(sessionToken, body) {\n    const res = await fetch(apiUrl('/auth/settings'), {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'X-Session-Token': sessionToken\n        },\n        body: JSON.stringify(body)\n    });\n    if (!res.ok) throw new Error('Failed to save settings');\n}\nfunction getLoginUrl() {\n    return '/auth/login';\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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bUJDO1FBQWE7SUFDN0M7SUFDQSxJQUFJLENBQUNGLElBQUlhLEVBQUUsRUFBRSxNQUFNLElBQUlJLE1BQU07SUFDN0IsT0FBT2pCLElBQUllLElBQUk7QUFDakI7QUFFTyxlQUFldUMsYUFDcEJwRCxZQUFvQixFQUNwQkssSUFBK0U7SUFFL0UsTUFBTVAsTUFBTSxNQUFNSyxNQUFNWixPQUFPLG1CQUFtQjtRQUNoRGEsUUFBUTtRQUNSTCxTQUFTO1lBQUUsZ0JBQWdCO1lBQW9CLG1CQUFtQkM7UUFBYTtRQUMvRUssTUFBTUMsS0FBS0MsU0FBUyxDQUFDRjtJQUN2QjtJQUNBLElBQUksQ0FBQ1AsSUFBSWEsRUFBRSxFQUFFLE1BQU0sSUFBSUksTUFBTTtBQUMvQjtBQUVPLFNBQVNzQztJQUNkLE9BQU87QUFDVCIsInNvdXJjZXMiOlsiQzpcXGRldlxcYWktZ2F0ZXdheVxcZGFzaGJvYXJkXFxsaWJcXGFwaS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogVXNlIHJlbGF0aXZlIHBhdGhzIHNvIHRoZSBicm93c2VyIGhpdHMgdGhlIHNhbWUgb3JpZ2luOyBOZXh0LmpzIHJld3JpdGVzIHByb3h5IHRvIHRoZSBnYXRld2F5IChubyBDT1JTKS4gKi9cclxuZnVuY3Rpb24gYXBpVXJsKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgcmV0dXJuIHBhdGguc3RhcnRzV2l0aCgnLycpID8gcGF0aCA6IGAvJHtwYXRofWBcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDaGF0T3B0aW9ucyB7XHJcbiAgLyoqIFdoZW4gdXNpbmcgU1NPLCBwYXNzIHNlc3Npb24gdG9rZW4gYW5kIG9taXQgYXBpS2V5ICovXHJcbiAgc2Vzc2lvblRva2VuPzogc3RyaW5nXHJcbiAgYXBpS2V5Pzogc3RyaW5nXHJcbiAgdXBzdHJlYW0/OiBzdHJpbmdcclxuICBtb2RlbDogc3RyaW5nXHJcbiAgbWVzc2FnZXM6IHsgcm9sZTogJ3VzZXInIHwgJ2Fzc2lzdGFudCcgfCAnc3lzdGVtJzsgY29udGVudDogc3RyaW5nIH1bXVxyXG4gIHN0cmVhbT86IGJvb2xlYW5cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNoYXRTdHJlYW0oXHJcbiAgb3B0czogQ2hhdE9wdGlvbnMsXHJcbiAgb25DaHVuazogKHRleHQ6IHN0cmluZykgPT4gdm9pZCxcclxuICBvbkRvbmU/OiAoKSA9PiB2b2lkXHJcbik6IFByb21pc2U8dm9pZD4ge1xyXG4gIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XHJcbiAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gIH1cclxuICBpZiAob3B0cy5zZXNzaW9uVG9rZW4pIHtcclxuICAgIGhlYWRlcnNbJ1gtU2Vzc2lvbi1Ub2tlbiddID0gb3B0cy5zZXNzaW9uVG9rZW5cclxuICB9IGVsc2UgaWYgKG9wdHMuYXBpS2V5KSB7XHJcbiAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7b3B0cy5hcGlLZXl9YFxyXG4gIH1cclxuICBpZiAob3B0cy51cHN0cmVhbSkgaGVhZGVyc1snWC1BSS1HYXRld2F5LVVwc3RyZWFtJ10gPSBvcHRzLnVwc3RyZWFtXHJcblxyXG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGFwaVVybCgnL3YxL2NoYXQvY29tcGxldGlvbnMnKSwge1xyXG4gICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICBoZWFkZXJzLFxyXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICBtb2RlbDogb3B0cy5tb2RlbCxcclxuICAgICAgbWVzc2FnZXM6IG9wdHMubWVzc2FnZXMsXHJcbiAgICAgIHN0cmVhbTogdHJ1ZSxcclxuICAgIH0pLFxyXG4gIH0pXHJcblxyXG4gIGlmICghcmVzLm9rKSB7XHJcbiAgICBjb25zdCBlcnIgPSBhd2FpdCByZXMuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoKGVyciBhcyB7IGVycm9yPzogeyBtZXNzYWdlPzogc3RyaW5nIH0gfSkuZXJyb3I/Lm1lc3NhZ2UgfHwgcmVzLnN0YXR1c1RleHQpXHJcbiAgfVxyXG5cclxuICBjb25zdCByZWFkZXIgPSByZXMuYm9keT8uZ2V0UmVhZGVyKClcclxuICBpZiAoIXJlYWRlcikgdGhyb3cgbmV3IEVycm9yKCdObyByZXNwb25zZSBib2R5JylcclxuXHJcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpXHJcbiAgbGV0IGJ1ZmZlciA9ICcnXHJcblxyXG4gIHRyeSB7XHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpXHJcbiAgICAgIGlmIChkb25lKSBicmVha1xyXG4gICAgICBidWZmZXIgKz0gZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pXHJcbiAgICAgIGNvbnN0IGxpbmVzID0gYnVmZmVyLnNwbGl0KCdcXG4nKVxyXG4gICAgICBidWZmZXIgPSBsaW5lcy5wb3AoKSA/PyAnJ1xyXG4gICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcclxuICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKCdkYXRhOiAnKSkge1xyXG4gICAgICAgICAgY29uc3QgZGF0YSA9IGxpbmUuc2xpY2UoNilcclxuICAgICAgICAgIGlmIChkYXRhID09PSAnW0RPTkVdJykgY29udGludWVcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGogPSBKU09OLnBhcnNlKGRhdGEpIGFzIHsgY2hvaWNlcz86IHsgZGVsdGE/OiB7IGNvbnRlbnQ/OiBzdHJpbmcgfSB9W10gfVxyXG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gai5jaG9pY2VzPy5bMF0/LmRlbHRhPy5jb250ZW50XHJcbiAgICAgICAgICAgIGlmIChjb250ZW50KSBvbkNodW5rKGNvbnRlbnQpXHJcbiAgICAgICAgICB9IGNhdGNoIHtcclxuICAgICAgICAgICAgLy8gc2tpcCBtYWxmb3JtZWQgY2h1bmtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGZpbmFsbHkge1xyXG4gICAgb25Eb25lPy4oKVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNoYXROb25TdHJlYW0ob3B0czogQ2hhdE9wdGlvbnMpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XHJcbiAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gIH1cclxuICBpZiAob3B0cy5zZXNzaW9uVG9rZW4pIGhlYWRlcnNbJ1gtU2Vzc2lvbi1Ub2tlbiddID0gb3B0cy5zZXNzaW9uVG9rZW5cclxuICBlbHNlIGlmIChvcHRzLmFwaUtleSkgaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke29wdHMuYXBpS2V5fWBcclxuICBpZiAob3B0cy51cHN0cmVhbSkgaGVhZGVyc1snWC1BSS1HYXRld2F5LVVwc3RyZWFtJ10gPSBvcHRzLnVwc3RyZWFtXHJcblxyXG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGFwaVVybCgnL3YxL2NoYXQvY29tcGxldGlvbnMnKSwge1xyXG4gICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICBoZWFkZXJzLFxyXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICBtb2RlbDogb3B0cy5tb2RlbCxcclxuICAgICAgbWVzc2FnZXM6IG9wdHMubWVzc2FnZXMsXHJcbiAgICAgIHN0cmVhbTogZmFsc2UsXHJcbiAgICB9KSxcclxuICB9KVxyXG5cclxuICBpZiAoIXJlcy5vaykge1xyXG4gICAgY29uc3QgZXJyID0gYXdhaXQgcmVzLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKChlcnIgYXMgeyBlcnJvcj86IHsgbWVzc2FnZT86IHN0cmluZyB9IH0pLmVycm9yPy5tZXNzYWdlIHx8IHJlcy5zdGF0dXNUZXh0KVxyXG4gIH1cclxuXHJcbiAgY29uc3QgZGF0YSA9IChhd2FpdCByZXMuanNvbigpKSBhcyB7IGNob2ljZXM/OiB7IG1lc3NhZ2U/OiB7IGNvbnRlbnQ/OiBzdHJpbmcgfSB9W10gfVxyXG4gIHJldHVybiBkYXRhLmNob2ljZXM/LlswXT8ubWVzc2FnZT8uY29udGVudCA/PyAnJ1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFZhbGlkYXRlQ3JlZGVudGlhbHNPcHRpb25zIHtcclxuICBhcGlLZXk6IHN0cmluZ1xyXG4gIHVwc3RyZWFtPzogc3RyaW5nXHJcbiAgbW9kZWw6IHN0cmluZ1xyXG59XHJcblxyXG4vKiogTWluaW1hbCByZXF1ZXN0IHRvIHZlcmlmeSB0aGUgQVBJIGtleSB3b3JrczsgdGhyb3dzIG9uIGludmFsaWQvZXJyb3IuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2YWxpZGF0ZUNyZWRlbnRpYWxzKG9wdHM6IFZhbGlkYXRlQ3JlZGVudGlhbHNPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgY29uc3QgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcclxuICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7b3B0cy5hcGlLZXl9YCxcclxuICB9XHJcbiAgaWYgKG9wdHMudXBzdHJlYW0pIGhlYWRlcnNbJ1gtQUktR2F0ZXdheS1VcHN0cmVhbSddID0gb3B0cy51cHN0cmVhbVxyXG5cclxuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChhcGlVcmwoJy92MS9jaGF0L2NvbXBsZXRpb25zJyksIHtcclxuICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgaGVhZGVycyxcclxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgbW9kZWw6IG9wdHMubW9kZWwsXHJcbiAgICAgIG1lc3NhZ2VzOiBbeyByb2xlOiAndXNlcicsIGNvbnRlbnQ6ICdIaScgfV0sXHJcbiAgICAgIG1heF90b2tlbnM6IDEsXHJcbiAgICAgIHN0cmVhbTogZmFsc2UsXHJcbiAgICB9KSxcclxuICB9KVxyXG5cclxuICBpZiAoIXJlcy5vaykge1xyXG4gICAgY29uc3QgZXJyID0gYXdhaXQgcmVzLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxyXG4gICAgY29uc3QgbXNnID0gKGVyciBhcyB7IGVycm9yPzogeyBtZXNzYWdlPzogc3RyaW5nIH0gfSkuZXJyb3I/Lm1lc3NhZ2VcclxuICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgcmVzLnN0YXR1c1RleHQgfHwgJ0ludmFsaWQgY3JlZGVudGlhbHMnKVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoQ29zdHMoKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBudW1iZXI+PiB7XHJcbiAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYXBpVXJsKCcvYXBpL2Nvc3RzJykpXHJcbiAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcihyZXMuc3RhdHVzVGV4dClcclxuICByZXR1cm4gcmVzLmpzb24oKVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFByb21wdExvZ0VudHJ5IHtcclxuICBpZDogc3RyaW5nXHJcbiAgdHM6IG51bWJlclxyXG4gIG1vZGVsOiBzdHJpbmdcclxuICBrZXlIaW50OiBzdHJpbmdcclxuICBwcm9tcHRUb2tlbnM/OiBudW1iZXJcclxuICBjb21wbGV0aW9uVG9rZW5zPzogbnVtYmVyXHJcbiAgcmVxdWVzdFByZXZpZXc/OiBzdHJpbmdcclxuICByZXNwb25zZVByZXZpZXc/OiBzdHJpbmdcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoUHJvbXB0TG9nKGxpbWl0ID0gNTApOiBQcm9taXNlPFByb21wdExvZ0VudHJ5W10+IHtcclxuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChhcGlVcmwoYC9hcGkvcHJvbXB0LWxvZz9saW1pdD0ke2xpbWl0fWApKVxyXG4gIGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IocmVzLnN0YXR1c1RleHQpXHJcbiAgcmV0dXJuIHJlcy5qc29uKClcclxufVxyXG5cclxuLyoqIEF1dGgg4oCUIGNvbmZpZyBmcm9tIG91ciBwcm94eSByb3V0ZSAocGF0aCBjaG9zZW4gc28gaXQgaXMgbm90IHJld3JpdHRlbiB0byB0aGUgZ2F0ZXdheSkuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBdXRoQ29uZmlnKCk6IFByb21pc2U8eyBzc29FbmFibGVkOiBib29sZWFuOyBsb2dpblVybDogc3RyaW5nIHwgbnVsbCB9PiB7XHJcbiAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goJy9nYXRld2F5LWF1dGgtY29uZmlnJylcclxuICBpZiAoIXJlcy5vaykgcmV0dXJuIHsgc3NvRW5hYmxlZDogZmFsc2UsIGxvZ2luVXJsOiBudWxsIH1cclxuICByZXR1cm4gcmVzLmpzb24oKVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEF1dGhVc2VyIHtcclxuICBpZDogc3RyaW5nXHJcbiAgZW1haWw6IHN0cmluZ1xyXG4gIG5hbWU/OiBzdHJpbmdcclxuICBwaWN0dXJlPzogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQXV0aFNldHRpbmdzIHtcclxuICBwcm92aWRlcjogc3RyaW5nXHJcbiAgdXBzdHJlYW06IHN0cmluZ1xyXG4gIG1vZGVsOiBzdHJpbmdcclxuICBoYXNBcGlLZXk6IGJvb2xlYW5cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE1lKHNlc3Npb25Ub2tlbjogc3RyaW5nKTogUHJvbWlzZTx7IHVzZXI6IEF1dGhVc2VyOyBzZXR0aW5nczogQXV0aFNldHRpbmdzIH0+IHtcclxuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChhcGlVcmwoJy9hdXRoL21lJyksIHtcclxuICAgIGhlYWRlcnM6IHsgJ1gtU2Vzc2lvbi1Ub2tlbic6IHNlc3Npb25Ub2tlbiB9LFxyXG4gIH0pXHJcbiAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcignU2Vzc2lvbiBpbnZhbGlkJylcclxuICByZXR1cm4gcmVzLmpzb24oKVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2F2ZVNldHRpbmdzKFxyXG4gIHNlc3Npb25Ub2tlbjogc3RyaW5nLFxyXG4gIGJvZHk6IHsgcHJvdmlkZXI/OiBzdHJpbmc7IHVwc3RyZWFtPzogc3RyaW5nOyBtb2RlbD86IHN0cmluZzsgYXBpS2V5Pzogc3RyaW5nIH1cclxuKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYXBpVXJsKCcvYXV0aC9zZXR0aW5ncycpLCB7XHJcbiAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJywgJ1gtU2Vzc2lvbi1Ub2tlbic6IHNlc3Npb25Ub2tlbiB9LFxyXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXHJcbiAgfSlcclxuICBpZiAoIXJlcy5vaykgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gc2F2ZSBzZXR0aW5ncycpXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2dpblVybCgpOiBzdHJpbmcge1xyXG4gIHJldHVybiAnL2F1dGgvbG9naW4nXHJcbn1cclxuIl0sIm5hbWVzIjpbImFwaVVybCIsInBhdGgiLCJzdGFydHNXaXRoIiwiY2hhdFN0cmVhbSIsIm9wdHMiLCJvbkNodW5rIiwib25Eb25lIiwicmVzIiwiaGVhZGVycyIsInNlc3Npb25Ub2tlbiIsImFwaUtleSIsInVwc3RyZWFtIiwiZmV0Y2giLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm1vZGVsIiwibWVzc2FnZXMiLCJzdHJlYW0iLCJvayIsImVyciIsImpzb24iLCJjYXRjaCIsIkVycm9yIiwiZXJyb3IiLCJtZXNzYWdlIiwic3RhdHVzVGV4dCIsInJlYWRlciIsImdldFJlYWRlciIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsImJ1ZmZlciIsImRvbmUiLCJ2YWx1ZSIsInJlYWQiLCJkZWNvZGUiLCJsaW5lcyIsInNwbGl0IiwicG9wIiwibGluZSIsImRhdGEiLCJzbGljZSIsImoiLCJwYXJzZSIsImNvbnRlbnQiLCJjaG9pY2VzIiwiZGVsdGEiLCJjaGF0Tm9uU3RyZWFtIiwidmFsaWRhdGVDcmVkZW50aWFscyIsIkF1dGhvcml6YXRpb24iLCJyb2xlIiwibWF4X3Rva2VucyIsIm1zZyIsImZldGNoQ29zdHMiLCJmZXRjaFByb21wdExvZyIsImxpbWl0IiwiZ2V0QXV0aENvbmZpZyIsInNzb0VuYWJsZWQiLCJsb2dpblVybCIsImdldE1lIiwic2F2ZVNldHRpbmdzIiwiZ2V0TG9naW5VcmwiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});